<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Probability spaces and probability measures</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-data/elasticlunr.min.js"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <script src="-verso-data/searchIndex.js"></script>
    <link rel="stylesheet" href="static/style.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
  text-decoration-skip-ink: none;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
  display: inline-grid;
  grid-template-columns: 1fr;
  vertical-align: top;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: inline-block;
  vertical-align: top;
  grid-row: 2;
  justify-self: start;
}

.hl.lean .tactic > label {
  position: relative;
  grid-row: 1;
}

@media (hover: hover) {
  .hl.lean .tactic:has(.tactic-toggle:not(:checked)) > label:hover {
    background-color: #eeeeee;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

.extra-doc-links {
  list-style-type: none;
  margin-left: 0;
  padding: 0;
}

.extra-doc-links > li {
  display: inline-block;
}

.extra-doc-links > li:not(:last-child)::after {
  content: '|';
  display: inline-block;
  margin: 0 0.25em;
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
            const extraLinks = tgt.parentElement.dataset['versoLinks'];
            if (extraLinks) {
              try {
                const extras = JSON.parse(extraLinks);
                const links = document.createElement('ul');
                links.className = 'extra-doc-links';
                extras.forEach((l) => {
                  const li = document.createElement('li');
                  li.innerHTML = "<a href=\"" + l['href'] + "\" title=\"" + l.long + "\">" + l.short + "</a>";
                  links.appendChild(li);
                });
                content.appendChild(links);
              } catch (error) {
                console.error(error);
              }
            }
          }
          return content;
        }
      };


      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic, .hl.lean .level-var, .hl.lean .level-const, .hl.lean .level-op, .hl.lean .sort', defaultTippyProps);
  });
}
</script>
    <link rel="icon" type="image/x-icon" href="static/favicon.svg">
    <script src="static/scripts.js"></script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper"></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Probability in Mathlib</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Probability in Mathlib</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot" checked="checked"></label><span class="">Table of Contents</span></div>
              <table><tr class="current numbered"><td class="num">1.</td><td><a href="Probability-spaces-and-probability-measures/#Probability-in-Mathlib--Probability-spaces-and-probability-measures">Probability spaces and probability measures</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Martingales/#Probability-in-Mathlib--Martingales">Martingales</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Various-probability-definitions/#Probability-in-Mathlib--Various-probability-definitions">Various probability definitions</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-Probability-in-Mathlib--Probability-spaces-and-probability-measures" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-Probability-in-Mathlib--Probability-spaces-and-probability-measures" checked="checked"></label><span class="number">1.</span> <span class="current"><a href="Probability-spaces-and-probability-measures/#Probability-in-Mathlib--Probability-spaces-and-probability-measures">Probability spaces and probability measures</a></span></div>
              <table><tr class="numbered"><td class="num">1.1.</td><td><a href="Probability-spaces-and-probability-measures/#Probability-in-Mathlib--Probability-spaces-and-probability-measures--Probability-of-events">Probability of events</a></td></tr><tr class="numbered"><td class="num">1.2.</td><td><a href="Probability-spaces-and-probability-measures/#Probability-in-Mathlib--Probability-spaces-and-probability-measures--Random-variables">Random variables</a></td></tr><tr class="numbered"><td class="num">1.3.</td><td><a href="Probability-spaces-and-probability-measures/#Probability-in-Mathlib--Probability-spaces-and-probability-measures--Discrete-probability">Discrete probability</a></td></tr><tr class="numbered"><td class="num">1.4.</td><td><a href="Probability-spaces-and-probability-measures/#Probability-in-Mathlib--Probability-spaces-and-probability-measures--Additional-typeclasses-on-measurable-spaces">Additional typeclasses on measurable spaces</a></td></tr></table></div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/RemyDegenne/demo-martingales">Source Code</a></li>
            <li>
              <a href="https://github.com/RemyDegenne/demo-martingales/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="#" rel="prev" title=" Probability in Mathlib"><span class="arrow">←</span><span class="where"> Probability in Mathlib</span></a><a class="local-button active" href="Martingales/#Probability-in-Mathlib--Martingales" rel="next" title="2. Martingales"><span class="where">2. Martingales</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              1. Probability spaces and probability measures</h1>
            <p>
              First, in order to work on probability we need a measurable space.
We can define a probability measure on such a space as follows.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-297" data-verso-hover="0">variable</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="1">Ω</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-2022587232982003368" data-verso-hover="2">Type*</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-MeasurableSpace" data-verso-hover="3">MeasurableSpace</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="1">Ω</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
  </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-MeasureTheory.Measure" data-verso-hover="5">Measure</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3" data-verso-hover="1">Ω</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-MeasureTheory.IsProbabilityMeasure" data-verso-hover="6">IsProbabilityMeasure</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.18" data-verso-hover="4">P</span><span class="unknown token" data-binding="">]</span></code><p>
              The class <code>MeasurableSpace Ω</code> defines a sigma-algebra on <code>Ω</code>. We then introduced a measure <code>P</code> on that sigma-algebra and specified that it should be a probability measure.
If we want to work on <code>ℝ</code> or another well known type the typeclass inference system will find <code>[MeasurableSpace ℝ]</code> on its own. We can write simply</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-431" data-verso-hover="0">variable</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-MeasureTheory.Measure" data-verso-hover="5">Measure</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-MeasureTheory.IsProbabilityMeasure" data-verso-hover="6">IsProbabilityMeasure</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36" data-verso-hover="7">P</span><span class="unknown token" data-binding="">]</span></code><p>
              With the code above, we can introduce several probability measures on the same space. When using lemmas and definitions about those measures, we will need to specify which measure we are talking about.
For example, the variance of a random variable <code>X</code> with respect to the measure <code>P</code> will be <code>variance X P</code>.</p>
            <p>
              But perhaps we just want a space with a canonical probability measure, which would be the one used without us having to tell Lean explicitly.
That can be done with the <code>MeasureSpace</code> class. A <code>MeasureSpace</code> is a <code>MeasurableSpace</code> with a canonical measure called <code>volume</code>.
The probability library of Mathlib defines a notation <code>ℙ</code> for that measure. We still need to tell that we want it to be a probability measure though.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-532" data-verso-hover="0">variable</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.48" data-verso-hover="1">Ω</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-2022587232982003368" data-verso-hover="2">Type*</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-MeasureTheory.MeasureSpace" data-verso-hover="8">MeasureSpace</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48" data-verso-hover="1">Ω</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-MeasureTheory.IsProbabilityMeasure" data-verso-hover="6">IsProbabilityMeasure</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">ℙ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-MeasureTheory.Measure" data-verso-hover="5">Measure</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48" data-verso-hover="1">Ω</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">]</span></code><p>
              Remark 1: in the code above we can't write only <code>[IsProbabilityMeasure ℙ]</code> because Lean would then not know to which space the default measure <code>ℙ</code> refers to.
That will not be necessary when we use <code>ℙ</code> in proofs because the context will be enough to infer <code>Ω</code>.</p>
            <p>
              Remark 2: a lemma written for <code>P : Measure Ω</code> in a <code>MeasurableSpace Ω</code> will apply for the special measure <code>ℙ</code> in a <code>MeasureSpace Ω</code>, but the converse is not true.
Mathlib focuses on generality, hence uses the <code>MeasurableSpace</code> spelling for its lemmas. In another context, the convenience of <code>MeasureSpace</code> may be preferable.</p>
            <p>
              Remark 3: <code>IsProbabilityMeasure</code> vs <code>ProbabilityMeasure</code>.
The examples above used <code>{P : Measure Ω} [IsProbabilityMeasure P]</code> to define a probability measure. That's the standard way to do it.
Mathlib also contains a type <code>ProbabilityMeasure Ω</code>: the subtype of measures that are probability measures.
The goal of that type is to work on the set of probability measures on <code>Ω</code>.
In particular, it comes with a topology, the topology of convergence in distribution (weak convergence of measures).
If we don't need to work with that topology, <code>{P : Measure Ω} [IsProbabilityMeasure P]</code> should be preferred.</p>
            <section>
              <h2 id="Probability-in-Mathlib--Probability-spaces-and-probability-measures--Probability-of-events">
                1.1. Probability of events</h2>
              <p>
                An event is a measurable set: there is no special event definition in Mathlib.
The probability of that event is the measure of the set.
A <code>Measure</code> can be applied to a set like a function and returns a value in <code>ENNReal</code> (denoted by <code>ℝ≥0∞</code>, available after <code>open scoped ENNReal</code>).</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-664">example</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.100" data-verso-hover="7">P</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-MeasureTheory.Measure" data-verso-hover="5">Measure</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.103" data-verso-hover="9">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Set" data-verso-hover="10">Set</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℝ≥0∞</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.100" data-verso-hover="7">P</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.103" data-verso-hover="9">s</span></code><p>
                The probability of the event <code>s</code> is thus <code>P s</code>.
The type <code>ℝ≥0∞</code> represents the nonnegative reals and infinity: the measure of a set is a nonnegative real number which in general may be infinite.
If <code>P</code> is a probability measure, it actually takes only values up to 1.
The tactic <code>simp</code> knows that a probability measure is finite and will use the lemmas <code>measure_ne_top</code> or <code>measure_lt_top</code> to prove that <code>P s ≠ ∞</code> or <code>P s &lt; ∞</code>.</p>
              <p>
                The operations on <code>ℝ≥0∞</code> are not as nicely behaved as on <code>ℝ</code>: <code>ℝ≥0∞</code> is not a ring. For example, subtraction truncates to zero.
If one finds that lemma <code>lemma_name</code> used to transform an equation does not apply to <code>ℝ≥0∞</code>, a good thing to try is to find a lemma named like <code>ENNReal.lemma_name_of_something</code> and use that instead (it will typically require that one variable is not infinite).</p>
              <p>
                For many lemmas to apply, the set <code>s</code> will need to be a measurable set. The way to express that is <code>MeasurableSet s</code>.</p>
              </section>
            <section>
              <h2 id="Probability-in-Mathlib--Probability-spaces-and-probability-measures--Random-variables">
                1.2. Random variables</h2>
              <p>
                A random variable is a measurable function from a measurable space to another.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-773" data-verso-hover="0">variable</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.266" data-verso-hover="1">Ω</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-2022587232982003368" data-verso-hover="2">Type*</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-MeasurableSpace" data-verso-hover="3">MeasurableSpace</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.266" data-verso-hover="1">Ω</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.273" data-verso-hover="11">X</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.266" data-verso-hover="1">Ω</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ℝ</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.372" data-verso-hover="12">hX</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Measurable" data-verso-hover="13">Measurable</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.273" data-verso-hover="11">X</span><span class="unknown token" data-binding="">)</span></code><p>
                In that code we defined a random variable <code>X</code> from the measurable space <code>Ω</code> to <code>ℝ</code> (for which the typeclass inference system finds a measurable space instance). The assumption <code>hX</code> states that <code>X</code> is measurable, which is necessary for most manipulations.</p>
              <p>
                If we define a measure <code>P</code> on <code>Ω</code>, we can talk about the law or distribution of a random variable <code>X : Ω → E</code>.
The law of <code>X</code> is a measure on <code>E</code>, with value <code>P (X ⁻¹' s)</code> on any measurable set <code>s</code> of <code>E</code>.
This is how we define the map of the measure <code>P</code> by <code>X</code>, <code>Measure.map X P</code> or more succinctly <code>P.map X</code>.
There is no specific notation for that law.
To say that <code>X</code> is Gaussian with mean 0 and variance 1, write <code>P.map X = gaussianReal 0 1</code>.</p>
              <p>
                The expectation of <code>X</code> is the integral of that function against the measure <code>P</code>, written <code>∫ ω, X ω ∂P</code>.
The notation <code>P[X]</code> is shorthand for that expectation. In a <code>MeasureSpace</code>, we can further use the notation <code>𝔼[X]</code>.</p>
              <p>
                Remark: there are two types of integrals in Mathlib, Bochner integrals and Lebesgue integrals.
The expectation notations stand for the Bochner integral, which is defined for <code>X : Ω → E</code> with <code>E</code> a normed space over <code>ℝ</code> (<code>[NormedAddCommGroup E] [NormedSpace ℝ E]</code>).
They don't work for <code>Y : Ω → ℝ≥0∞</code> since <code>ℝ≥0∞</code> is not a normed space, but those functions can be integrated with the Lebesgue integral: <code>∫⁻ ω, Y ω ∂P</code>.
There is no expectation notation for the Lebesgue integral.</p>
              </section>
            <section>
              <h2 id="Probability-in-Mathlib--Probability-spaces-and-probability-measures--Discrete-probability">
                1.3. Discrete probability</h2>
              <p>
                In discrete probability, measurability is not an issue: every set and every function are measurable.
The typeclass <code>[DiscreteMeasurableSpace Ω]</code> signals that every set of <code>Ω</code> is measurable and the lemma <code>MeasurableSet.of_discrete</code> provides a proof of measurability.
To obtain measurability of a function from <code>Ω</code>, use <code>Measurable.of_discrete</code>.</p>
              <p>
                Any countable type with measurable singletons is a <code>DiscreteMeasurableSpace</code>, for example <code>ℕ</code> or <code>Fin n</code>.</p>
              <p>
                A way to define a probability measure on a discrete space <code>Ω</code> is to use the type <code>PMF Ω</code>, which stands for probability mass function.
<code>PMF Ω</code> is the subtype of functions <code>Ω → ℝ≥0∞</code> that sum to 1.
One can get a <code>Measure Ω</code> from <code>p : PMF Ω</code> with <code>p.toMeasure</code>.
When writing a theorem about probability on finite spaces, it preferable to write it for a <code>Measure</code> in a <code>DiscreteMeasurableSpace</code> than for a <code>PMF</code> for better integration with the library.</p>
              </section>
            <section>
              <h2 id="Probability-in-Mathlib--Probability-spaces-and-probability-measures--Additional-typeclasses-on-measurable-spaces">
                1.4. Additional typeclasses on measurable spaces</h2>
              <p>
                Some results in probability theory require the sigma-algebra to be the Borel sigma-algebra, generated by the open sets. For example, with the Borel sigma-algebra the open sets are measurable and continuous functions are measurable.
For that we first need <code>Ω</code> to be a topological space and we then need to add a <code>[BorelSpace Ω]</code> variable.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.variable-901" data-verso-hover="0">variable</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.375" data-verso-hover="1">Ω</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="sort-2022587232982003368" data-verso-hover="2">Type*</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-MeasurableSpace" data-verso-hover="3">MeasurableSpace</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.375" data-verso-hover="1">Ω</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-TopologicalSpace" data-verso-hover="14">TopologicalSpace</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.375" data-verso-hover="1">Ω</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-BorelSpace" data-verso-hover="15">BorelSpace</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.375" data-verso-hover="1">Ω</span><span class="unknown token" data-binding="">]</span></code><p>
                For properties related to conditional distributions, it is often convenient or necessary to work in a standard Borel space (a measurable space arising as the Borel sets of some Polish topology). See the <code>StandardBorelSpace</code> typeclass.
Note that a countable discrete measurable space is a standard Borel space, so there is no need to worry about that typeclass when doing discrete probability.
</p>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="#" rel="prev" title=" Probability in Mathlib"><span class="arrow">←</span><span class="where"> Probability in Mathlib</span></a><a class="local-button active" href="Martingales/#Probability-in-Mathlib--Martingales" rel="next" title="2. Martingales"><span class="where">2. Martingales</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

